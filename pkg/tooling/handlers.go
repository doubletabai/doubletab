package tooling

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"

	"github.com/openai/openai-go"
	"github.com/pterm/pterm"
	"github.com/rs/zerolog/log"

	"github.com/doubletabai/doubletab/pkg/vector"
)

const (
	generateServerCodePrompt = `You are an AI assistant that generates Go code implementing server based on previously generated OpenAPI 3.0 spec.

Implement ServerInterface generated by oapi-codegen. Your workflow is as follows:

1. Check the knowledge base for best practices and sample code.
2. Query the memory for generated handlers code to see what structs and what interfaces are there.
3. Implement the ServerInterface methods strictly following sample code from the knowledge base.
4. Save the code to the server.go file in the api package.
5. Build the server code. If it fails, address the build errors and re-generate the server code.

Important notes:
- Don't create any new types for resources, use the ones provided by the generated handlers code. Stick to the sample
  code provided by the knowledge base.
- Don't ask the user for any additional information, use the OpenAPI spec and generated handlers code spec as the source of truth.
`
)

const GenerateHandlersCodeToolName = "generate_handlers_code"

func (s *Service) GenerateHandlersCodeTool() openai.ChatCompletionToolParam {
	return openai.ChatCompletionToolParam{
		Type: openai.F(openai.ChatCompletionToolTypeFunction),
		Function: openai.F(openai.FunctionDefinitionParam{
			Name:        openai.String(GenerateHandlersCodeToolName),
			Description: openai.String("Generates Go code implementing handlers based on previously generated OpenAPI 3.0 spec."),
		}),
	}
}

const GenerateServerCodeToolName = "generate_server_code"

func (s *Service) GenerateServerCodeTool() openai.ChatCompletionToolParam {
	return openai.ChatCompletionToolParam{
		Type: openai.F(openai.ChatCompletionToolTypeFunction),
		Function: openai.F(openai.FunctionDefinitionParam{
			Name:        openai.String(GenerateServerCodeToolName),
			Description: openai.String("Generates Go code implementing server based on previously generated OpenAPI 3.0 spec."),
			Parameters: openai.F(openai.FunctionParameters{
				"type": "object",
				"properties": map[string]interface{}{
					"openapi_spec": map[string]string{
						"type": "string",
					},
				},
				"required": []string{"openapi_spec"},
			}),
		}),
	}
}

const SaveServerCodeToolName = "save_server_code"

func (s *Service) SaveServerCodeTool() openai.ChatCompletionToolParam {
	return openai.ChatCompletionToolParam{
		Type: openai.F(openai.ChatCompletionToolTypeFunction),
		Function: openai.F(openai.FunctionDefinitionParam{
			Name:        openai.String(SaveServerCodeToolName),
			Description: openai.String("Save generated server Go code to the server.go file in the api package."),
			Parameters: openai.F(openai.FunctionParameters{
				"type": "object",
				"properties": map[string]interface{}{
					"server_go_code": map[string]string{
						"type": "string",
					},
				},
				"required": []string{"server_go_code"},
			}),
		}),
	}
}

func (s *Service) GenerateHandlersCode(ctx context.Context) string {
	spinner, _ := pterm.DefaultSpinner.Start("Generating handlers...")
	defer spinner.Stop()

	absRoot, err := filepath.Abs(os.Getenv("PROJECT_ROOT"))
	if err != nil {
		return fmt.Sprintf("Failed to get absolute path of project root: %v", err)
	}
	cmd := exec.CommandContext(ctx, "go", "generate", "./...")
	cmd.Dir = absRoot

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Sprintf("go generate failed: %v\n%s", err, output)
	}

	handlersGo, err := os.ReadFile(filepath.Join(absRoot, "pkg", "api", "handlers.gen.go"))
	if err != nil {
		return fmt.Sprintf("Failed to read generated handlers file (handlers.gen.go): %v", err)
	}

	if err := s.Mem.Store(ctx, vector.RoleTool, string(handlersGo)); err != nil {
		log.Err(err).Msg("Failed to store generated handlers code in memory")
	}

	return "Handlers code generated successfully"
}

func (s *Service) GenerateServerCode(ctx context.Context, arguments string) string {
	spinner, _ := pterm.DefaultSpinner.Start("Generating server code...")
	defer spinner.Stop()

	var args map[string]interface{}
	if err := json.Unmarshal([]byte(arguments), &args); err != nil {
		return fmt.Sprintf("Failed to unmarshal function arguments: %v", err)
	}
	openApiSpec := args["openapi_spec"].(string)

	log.Debug().Msgf("Creating server code for OpenAPI spec: %s", openApiSpec)

	agent := s.Agent(generateServerCodePrompt, openApiSpec).
		WithTools(s.QueryKnowledgeBaseTool(), s.QueryMemoryTool(), s.SaveServerCodeTool(), s.BuildCodeTool()).
		WithModel(s.CodeModel)

	return agent.Run(ctx)
}

func (s *Service) SaveServerCode(_ context.Context, arguments string) string {
	apiDir := path.Join(os.Getenv("PROJECT_ROOT"), "pkg", "api")
	fh, err := os.Create(path.Join(apiDir, "server.go"))
	if err != nil {
		return fmt.Sprintf("Failed to create server.go file: %v", err)
	}
	defer fh.Close()

	var args map[string]interface{}
	if err := json.Unmarshal([]byte(arguments), &args); err != nil {
		return fmt.Sprintf("Failed to unmarshal function arguments: %v", err)
	}
	code := args["server_go_code"].(string)
	code = TrimNonCode(code, "go")

	_, err = fh.WriteString(code)
	if err != nil {
		return fmt.Sprintf("Failed to write server.go file: %v", err)
	}

	return "Server code saved successfully"
}
